Denne oppgaven er en offentlig Google eksempel test. 

Gitt en matrise av heltall, returner indeksen til to tall som summeres til et gitt mål. 
 
 Vi vil få to parametere inn. Først en matrise av heltall og så et måltall som også er et heltall. 

 F.eks:

 [2,3,5,6,9], 11  returnerer [2,3]

 Bekrefte begrsningene til oppgaven: 

* Er alle tallene positive eller kan de være negative?
  Svar: Alle er positive
* Er du duplikat nummer i matrisen.
  Svar: Nei
* Vil det alltid være en løsning tilgjengelig.
  Svar: Nei, det vil ikke alltid være en løsning. 
  (Vi kan få en matrise som ikke har to tall som summert blir måltallet, eller vi kan få en tom matrise, eller en matrise med bare ett tall.)
* Hva skal returneres hvis det ikke eksister noen løsning?
  Svar: Returner null
* Kan det være flere par som summert blir måltallet? 
  Svar: Nei. Bare ett par kan summeres til måltallet.

  Test tilfeller:

  [2,3,5,6,9] => 11  returnerer [2,3]  // Optimalt tilfelle
    
  [2,3] => 5 returnerer [0,1]

  [2,3,5,6,9] => 19  returnerer null

  [] => 1 returnerer null
  
  [3] => 3 returnerer null

  ----------------------------------------------

  Finne en løsning uten kode: 

  [2,3,5,6,9] => 15

  Hvordan vil du løse denne logisk?

  Sjekke alle tallene  mot hverandre for å se om noen av dem summert blir måltallet. Vi er her ikke interessert i den optimale løsningen, først vil vi ha en løsnige som virker. 

  Starter med det første tallet i matrisen. 2+3, 2+5, 2+6 , 2+9 => Ingen av disse blir 15 så vi vet at 2 ikke er en del av løsnigen. 
  Vi prøver med det andre tallet i matrisen. 3+5, 3+6 , 3+9 => Ingen av disse blir 15 så vi vet at 3 ikke er en del av løsnigen. 
  Vi prøver med det tredje tallet i matrisen. 5+6 , 5+9 => Ingen av disse blir 15 så vi vet at 5 ikke er en del av løsnigen. 
  Vi prøver med det fjerde tallet i matrisen. 6+9 => Dette paret blir 15 så vi vet at 6 og 9 er løsnigen. Og svaret blir indeksen til tallene 6 og 9 => [3,4]


  Algoritme:
  Hvis p1 er tallet vi tester ut og p2 er tallene vi prøver å summere med og t er måltallet, kan vi skrive algoritmen slik: 

  Tallet vi skal finne (p2) = måltallet t - p1 
  p2 = t - numbers[p1]

  Første runde: T = 15, p1 = 2, så tallet vi leteer etter er: 15 - 2 = 13. p2 = 13. Vi løper gjennom hele matrisen fra start indeks 0, til vi enten finner p2 (13) eller kommer til slutten av matrisen. 

  Hvis vi ikke fant et tallpar går vi videre til runde to. Vi tilorder p1 til tallet i posisjon 2. p1 = numbers[1] som er 3. 
  Andre runde: T = 15, p1 = 3, så tallet vi leteer etter er: 15 - 3 = 12. p2 = 12. Vi løper gjennom hele matrisen fra start indeks 1, siden vi allerede har testet number[0], 
  til vi enten finner p2 (12) eller kommer til slutten av matrisen. 

  Hvis vi finner tallet før vi kommer til slutten av matrisen så returnere vi en matrise med indeksene til p1 og p2. I vårt tilfelle vil vi få riktig sum når p1 = numbers[3] og p2 = [4] så vi returnerer [3,4]

  Hvis vi kommer til så langt at vi sjekker det nest siste tallet i matrisen med det siste tallet i matrisen uten å finne et tallpar som blir 15, returnere vi null

  -----

  Mer effektiv løsning. 

  Vi har to løkker i løsningen vår. 
  * Den første løkken finner tallet vi leter etter ved å subtrahere det første tallet i matrisen fra måltallet. 
  * Den andre løkken sjekker tallene i matrisen en etter en for å se om det er noen som svarer til tallet vi skal finne. 
  Når løkken er ferdig så kastes tallet bort og all beregning som er gjort.

  Hvis vi i stedet for å sjekke tallet vi ønsker å finne i den første løkken, lagrer det i en Dicionary så kan vi bruke det for å sjekke om vi har et treff. 
  Vi ønsnker å bruke en Dicionary fordi et oppslag i en Dicionary har en kostnad på O(1) så lenge vi har nøkkelen. 

  Nøkkelen vi ønsker å bruke her er tallet vi ønsker å finne. 

  Først finner vi tallet vi ønsker å  finne ved å subtrahere Numbers[0] fra måltallet. Dette nummeret vi ønkser å finne lagrer vi som en nøkkel i en Dicionary med index 0 som verdien.
  Deretter fortsetter vi løkken til P1. 
  * Først kalkulerer vi tallet vi ønsker å finne ved å subtrahere Numbers[1] fra måltallet.
  * Finnes dette tallet i vår Dicionary?
     - Hvis ja, vi har funnet løsningen
     - Hvis nei, vi lagrer tallet vi øsnker å finne som en ny nøkkel i vår Dicionary og indeks p1 som verdien
  
  Gjenta prosedyren til vi enten har et treff i vår Dicionary, eller har gått gjennom hele matrisen. 

   [2,3,5,6,9] => 15

   13 : 0
   12 : 1
   10 : 2
   9 : 3   => treff på 9 og p1 = 4

  Når vi får et treff reutrnerer vi verdien av nøkkelen til tallet som er et treff og p1 som er indeks til det tallet som vi tester med.


  Hvis vi ser på vår BigO så har vi gått fra:
  * Tid: O(N^2)
  * Plass: O(1)

  Vi løper bare over matrisen en gang, men vi lagrer alle de beregnede tallene som vi ønsker å finne i en Dictionary noe vi ikke gjorde tidligere. 
  Til:
  * Tid: O(N)
  * Plass O(N)





